module MerkleTree.New.High.Correct

open FStar.Seq

open MerkleTree.Spec
open MerkleTree.New.High
open MerkleTree.New.High.Correct.Base
open MerkleTree.New.High.Correct.Insertion
open MerkleTree.New.High.Correct.Rhs
open MerkleTree.New.High.Correct.Flushing
open MerkleTree.New.High.Correct.Path

module S = FStar.Seq

module Insertion = MerkleTree.New.High.Correct.Insertion
module Rhs = MerkleTree.New.High.Correct.Rhs
module Flushing = MerkleTree.New.High.Correct.Flushing
module Path = MerkleTree.New.High.Correct.Path

module Spec = MerkleTree.Spec

#set-options "--z3rlimit 20 --max_fuel 0 --max_ifuel 0"

/// Correctness of the high-level Merkle tree design

// We claim below statements as the correctness of the high-level Merkle tree design:
// 1) There is an invariant (`mt_inv`), and `create_mt` satisfies it.
// 2) The invariant is preserved for insertion and flushing.
// 3) Assuming the invariant, we can construct the specification (`mt_spec`) for a given tree.
// 4) Merkle paths generated by the design and the corresponding spec are equal.
// 5) Merkle path verification by the design and the spec give the same result.

type old_hashes (mt: merkle_tree) =
  olds:hash_ss{S.length olds = 32 /\ mt_olds_inv 0 (MT?.i mt) olds}

noeq type mt_olds =
| MTO: mt:merkle_tree{mt_wf_elts mt} ->
       olds: old_hashes mt ->
       mt_olds

val mto_inv: mt_olds -> GTot Type0
let mto_inv mto =
  mt_inv (MTO?.mt mto) (MTO?.olds mto)

val mto_base: mto:mt_olds -> GTot (hs:hash_seq{S.length hs = MT?.j (MTO?.mt mto)})
let mto_base mto =
  mt_base (MTO?.mt mto) (MTO?.olds mto)

val mto_spec:
  mto:mt_olds{MT?.j (MTO?.mt mto) > 0} ->
  GTot (Spec.merkle_tree (log2c (MT?.j (MTO?.mt mto))))
let mto_spec mto =
  mt_spec (MTO?.mt mto) (MTO?.olds mto)

// `create_mt` is correct.

val create_mt_ok:
  init:hash ->
  Lemma (empty_olds_inv 0;
         mto_inv (MTO (create_mt init) (empty_hashes 32)))
let create_mt_ok init =
  Insertion.create_mt_inv_ok init

// `mt_insert` is correct.

val mt_insert_ok:
  mto:mt_olds -> v:hash ->
  Lemma (requires mto_inv mto /\ mt_not_full (MTO?.mt mto))
        (ensures  mto_inv (MTO (mt_insert (MTO?.mt mto) v) (MTO?.olds mto)))
let mt_insert_ok mto v =
  Insertion.mt_insert_inv_preserved (MTO?.mt mto) v (MTO?.olds mto)

// `mt_flush_to` and `mt_flush` are correct.

val mt_flush_to_ok:
  mto:mt_olds ->
  idx:nat{idx >= MT?.i (MTO?.mt mto) /\ idx < MT?.j (MTO?.mt mto)} ->
  Lemma (requires mto_inv mto)
        (ensures  mto_inv (MTO (mt_flush_to (MTO?.mt mto) idx)
                               (mt_flush_to_olds 0 (MT?.i (MTO?.mt mto)) idx (MT?.j (MTO?.mt mto))
                                 (MTO?.olds mto) (MT?.hs (MTO?.mt mto)))))
let mt_flush_to_ok mto idx =
  Flushing.mt_flush_to_inv_preserved (MTO?.mt mto) (MTO?.olds mto) idx

val mt_flush_ok:
  mto:mt_olds ->
  Lemma (requires mto_inv mto /\ MT?.j (MTO?.mt mto) > MT?.i (MTO?.mt mto))
        (ensures  mto_inv (MTO (mt_flush_to (MTO?.mt mto) (MT?.j (MTO?.mt mto) - 1))
                               (mt_flush_to_olds 0 (MT?.i (MTO?.mt mto))
                                 (MT?.j (MTO?.mt mto) - 1) (MT?.j (MTO?.mt mto))
                                 (MTO?.olds mto) (MT?.hs (MTO?.mt mto)))))
let mt_flush_ok mto =
  Flushing.mt_flush_inv_preserved (MTO?.mt mto) (MTO?.olds mto)

// `mt_get_root` is correct.

val mt_get_root_ok:
  mto:mt_olds -> drt:hash ->
  Lemma (requires mto_inv mto)
        (ensures (let nmt, rt = mt_get_root (MTO?.mt mto) drt in
                 // Only `MT?.rhs` and `MT?.mroot` are changed.
                 MT?.i (MTO?.mt mto) == MT?.i nmt /\
                 MT?.j (MTO?.mt mto) == MT?.j nmt /\
                 MT?.hs (MTO?.mt mto) == MT?.hs nmt /\
                 // A Merkle tree with new `MT?.rhs` and `MT?.mroot` is valid.
                 mt_inv nmt (MTO?.olds mto) /\
                 // A returned root is indeed the Merkle root.
                 rt == MT?.mroot nmt))
let mt_get_root_ok mto drt =
  Rhs.mt_get_root_inv_ok (MTO?.mt mto) drt (MTO?.olds mto)

// `mt_get_path` is correct.

val mt_get_path_ok:
  mto:mt_olds ->
  idx:nat{MT?.i (MTO?.mt mto) <= idx && idx < MT?.j (MTO?.mt mto)} ->
  drt:hash ->
  Lemma (requires mto_inv mto /\ MT?.j (MTO?.mt mto) > 0)
        (ensures (let j, p, rt = mt_get_path (MTO?.mt mto) idx drt in
                 j == MT?.j (MTO?.mt mto) /\
                 mt_root_inv (mto_base mto) hash_init false rt /\
                 S.head p == S.index (mto_base mto) idx /\
                 (assert (S.length (S.tail p) == mt_path_length idx (MT?.j (MTO?.mt mto)) false);
                 S.equal (path_spec idx (MT?.j (MTO?.mt mto)) false (S.tail p))
                         (Spec.mt_get_path #(log2c j) (mto_spec mto) idx))))
let mt_get_path_ok mto idx drt =
  Path.mt_get_path_inv_ok (MTO?.mt mto) (MTO?.olds mto) idx drt

// `mt_verify` is correct.

val mt_verify_ok:
  k:nat ->
  j:nat{k < j} ->
  p:path{S.length p = 1 + mt_path_length k j false} ->
  rt:hash ->
  Lemma (mt_verify k j p rt <==>
         Spec.mt_verify #(log2c j)
           (path_spec k j false (S.tail p)) k (HRaw (S.head p)) (HRaw rt))
let mt_verify_ok k j p rt =
  Path.mt_verify_ok k j p rt
